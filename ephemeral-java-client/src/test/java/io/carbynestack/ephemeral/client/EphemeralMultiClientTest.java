/*
 * Copyright (c) 2021 - for information on the respective copyright owner
 * see the NOTICE file and/or the repository https://github.com/carbynestack/ephemeral.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package io.carbynestack.ephemeral.client;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.powermock.api.mockito.PowerMockito.verifyNew;
import static org.powermock.api.mockito.PowerMockito.whenNew;

import io.vavr.concurrent.Future;
import io.vavr.control.Either;
import io.vavr.control.Option;
import java.net.URI;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

@RunWith(PowerMockRunner.class)
@PrepareForTest(EphemeralClient.class)
public class EphemeralMultiClientTest {

  private static final String APPLICATION = "app";
  private static final String CODE = "a = sint(1)";
  private final ArgumentCaptor<Activation> activationArgumentCaptor =
      ArgumentCaptor.forClass(Activation.class);
  private final List<UUID> inputObjects = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
  private final String[] inputSecretIdArray =
      inputObjects.stream().map(UUID::toString).toArray(String[]::new);
  private final Activation activation =
      Activation.builder().code(CODE).amphoraParams(inputSecretIdArray).build();

  @Mock private EphemeralClient client1Mock;

  @Mock private EphemeralClient client2Mock;

  private EphemeralMultiClient client;

  @Before
  public void setUp() {
    client = new EphemeralMultiClient(Arrays.asList(client1Mock, client2Mock));
  }

  @Test
  public void givenServiceUrlsIsNull_whenCreateClient_thenThrowException() {
    @SuppressWarnings("ConstantConditions")
    NullPointerException npe =
        assertThrows(
            NullPointerException.class,
            () -> new EphemeralMultiClient.Builder().withEndpoints(null).build());
    assertThat(npe.getMessage(), containsString("is null"));
  }

  @Test
  public void givenSuccessful_whenExecuteProgram_thenReturnResult() {
    ActivationResult result = new ActivationResult(Collections.singletonList(UUID.randomUUID()));
    when(client1Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.right(result)));
    when(client2Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.right(result)));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertThat(results.get().get(), equalTo(Arrays.asList(result, result)));
    verify(client1Mock, times(1)).execute(activationArgumentCaptor.capture());
    Activation capturedActivation = activationArgumentCaptor.getValue();
    assertEquals(CODE, capturedActivation.getCode());
    assertNotNull("GameId must me autogenerated (not null).", capturedActivation.getGameId());
    assertArrayEquals(inputSecretIdArray, capturedActivation.getAmphoraParams());
    verify(client2Mock, times(1)).execute(capturedActivation);
  }

  @Test
  public void givenServiceRespondsUnsuccessful_whenExecuteProgram_thenReturnFailureCode() {
    int httpFailureCode = 404;
    String errMessage = "an unexpected error";
    ActivationError activationError =
        new ActivationError().setMessage(errMessage).setResponseCode(httpFailureCode);
    when(client1Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.left(activationError)));
    when(client2Mock.execute(any(Activation.class)))
        .thenReturn(Future.successful(Either.left(activationError)));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertThat(results.get().getLeft().responseCode, equalTo(httpFailureCode));
    assertThat(results.get().getLeft().message, equalTo(errMessage));
    verify(client1Mock, times(1)).execute(any(Activation.class));
    verify(client2Mock, times(1)).execute(any(Activation.class));
  }

  @Test
  public void givenServiceCommunicationFails_whenExecuteProgram_thenFutureFails() {
    Exception failure = new Exception("an unexpected error");
    when(client1Mock.execute(any(Activation.class))).thenReturn(Future.failed(failure));
    when(client2Mock.execute(any(Activation.class))).thenReturn(Future.failed(failure));
    Future<Either<ActivationError, List<ActivationResult>>> results =
        client.execute(activation.getCode(), inputObjects);
    results.await();
    assertTrue(results.isFailure());
    verify(client1Mock, times(1)).execute(any(Activation.class));
    verify(client2Mock, times(1)).execute(any(Activation.class));
  }

  @Test
  public void givenBearerTokenProvider_whenCreateClient_thenCorrectBearerTokensAreUsed()
      throws Exception {
    String token = RandomStringUtils.randomAlphanumeric(20);
    EphemeralEndpoint endpoint = new EphemeralEndpoint(new URI("https://example.com"), APPLICATION);
    whenNew(EphemeralClient.class).withArguments(any(), any(), any()).thenReturn(client1Mock);
    new EphemeralMultiClient.Builder()
        .withEndpoints(Arrays.asList(endpoint, endpoint))
        .withBearerTokenProvider(e -> token)
        .build();
    verifyNew(EphemeralClient.class, times(2))
        .withArguments(any(), any(), any(), eq(Option.some(token)), any());
  }
}
